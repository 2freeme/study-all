---
typora-root-url: image
---

# 欠缺部分

##### ThreadLocal 

##### B+树的树深

##### CAP的理论知识及一些常见的组件

##### 技术选型的对比（例如mq）

##### springCloud的一些知识的储备

##### 高并发场景的解决办法

##### mysql巨大数据量的处理

##### rocketMq的延迟的原理

##### DDD的理解

##### jvm的深入（短时间看不完了）



### 补充

#### 技术选型

##### MQ

- **RabbitMQ**

  erlang开发，延迟比较低

  **RocketMQ**

  java开发，面向互联网集群化功能丰富 可以支持几百个topic

  **kafka**

  Scala开发，面向日志功能丰富  几十到几百的时候会性能下降

  **ActiveMQ**

  java开发，简单，稳定 但是并发级别比较低

- 消息的作用：
  - 解耦  减少系统依赖，提高可用性
  - 异步  减少相应时间，提升用户体验
  - 销峰  高流量销峰，提高可用行
  - 缺点：
    - 系统的可用性变低，因为引入了其他的组件
    - 系统的复杂性提高，因为会涉及到，重复消费，幂等之类的
    - 数据的一致性，因为涉及到了异步
  
- mq的死信队列

- mq的顺序消费的机制

  - 即使是Topic的分片，发送的时候，是把他放在特定的broker中的特定queue中的

- mq的延迟的机制





#### ThreadLocal

- 当很多线程需要多次使用同一个对象，并且需要该对象具有相同初始化值的时候最适合使用ThreadLocal。

- https://www.pianshen.com/article/2853116327/

- http://www.threadlocal.cn/#1

##### threadlocal使用

- 每次使用完ThreadLocal都调用它的remove()方法清除数据

- 将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。
- 这里会涉及到java的引用类型和 java的对象的生命周期

##### java引用类型

​		每种编程语言都有自己操作内存中元素的方式，例如在 C 和 C++ 里是通过指针，而在 Java 中则是通过“引用”。在 Java 中一切都被视为了对象，但是我们操作的标识符实际上是对象的一个引用（reference）。

`//创建一个引用，引用可以独立存在，并不一定需要与一个对象关联 String s;`

- 引用回收
  - 引用计数法：为每个对象添加一个引用计数器，每当有一个引用指向它时，计数器就加1，当引用失效时，计数器就减1，当计数器为0时，则认为该对象可以被回收（目前在Java中已经弃用这种方式了）。
  - 可达性分析算法：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。

- 强引用

  - 使用最普遍的引用，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。
  - 如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时间就会回收该对象。

- 软引用

  - 软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。

- 弱引用

  - VM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。

    ```java
    	private static void testWeakReference() {
    		for (int i = 0; i < 10; i++) {
    			byte[] buff = new byte[1024 * 1024];
    			WeakReference<byte[]> sr = new WeakReference<>(buff);
    			list.add(sr);
    		}
    		
    		System.gc(); //主动通知垃圾回收
    		
    		for(int i=0; i < list.size(); i++){
    			Object obj = ((WeakReference) list.get(i)).get();
    			System.out.println(obj);
    		}
    	}
    ```

- 虚引用

  - 虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。

- 引用队列

  - 引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。

    与软引用、弱引用不同，虚引用必须和引用队列一起使用。

##### java类生命周期

​		java类的生命周期就是指一个class文件从加载到卸载的全过程。

​		https://blog.csdn.net/yanliguoyifang/article/details/80964237![类的生命周期](/类的生命周期.jpg)

​		 其中，验证——准备——解析 称为连接阶段，除了解析外，其他阶段是顺序发生的，而解析可以与这些阶段交叉进行，因为Java支持动态绑定（晚期绑定），需要运行时才能确定具体类型；在使用阶段实例化对象。

- 类的初始化触发
  - 类的加载机制没有明确的触发条件，但是有5种情况下必须对类进行初始化，那么 加载——验证——准备 就必须在此之前完成了。
    - 通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。
    - 通过反射方式执行以上三种行为。
    - 初始化子类的时候，会触发父类的初始化。
    - 虚拟机启动时，初始化一个执行主类；（作为程序入口直接运行时（也就是直接调用main方法）。）
    - 使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、RE_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化
  - 注意，**有且只有五种情况必须对类进行初始化，这**五种情况被称为“主动引用”，除了这五种情况，所有其他的类引用方式都不会触发类初始化，被称为“被动引用”



