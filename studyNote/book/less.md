---
typora-root-url: image
---

# 欠缺部分

##### ThreadLocal 

##### B+树的树深

##### CAP的理论知识及一些常见的组件

##### 技术选型的对比（例如mq）

##### springCloud的一些知识的储备

##### 高并发场景的解决办法

##### mysql巨大数据量的处理

##### rocketMq的延迟的原理

##### DDD的理解

##### jvm的深入（短时间看不完了）



## 补充

增加性能的最快捷的方式就是解耦，各司其职，分而治之

### 技术选型

### MQ

- **RabbitMQ**

  erlang开发，延迟比较低

  **RocketMQ**

  java开发，面向互联网集群化功能丰富 可以支持几百个topic

  **kafka**

  Scala开发，面向日志功能丰富  几十到几百的时候会性能下降

  **ActiveMQ**

  java开发，简单，稳定 但是并发级别比较低

- 消息的作用：
  - 解耦  减少系统依赖，提高可用性
  - 异步  减少相应时间，提升用户体验
  - 销峰  高流量销峰，提高可用行
  - 缺点：
    - 系统的可用性变低，因为引入了其他的组件
    - 系统的复杂性提高，因为会涉及到，重复消费，幂等之类的
    - 数据的一致性，因为涉及到了异步
  
- mq的死信队列

- mq的顺序消费的机制

  - 即使是Topic的分片，发送的时候，是把他放在特定的broker中的特定queue中的。
  - 之所以需要topic的分片是因为，本身的话做消息的负载均衡
  - 一个queue只会被一个consumer进行消费

- mq的延迟的机制

  - RocketMQ提供了延时消息类型，简单来说就是生产者在发送消息的时候指定一个延时时间，当到达延时时间之后消息才能够被投送到消费者。
  - 

- mq的producer

  - 是以groupname 和  ip地址作为一个唯一标识



### java中的锁

#### CAS 自旋锁

- compare and set  乐观锁的一种，会拿出当前的值，然后进行操作，然后结束的时候将现在的值和以前的拿出来的值进行对比，然后再判断是否成功

  ![](/CAS自旋锁2.jpg)

  - 问题：这种问题可能会比较明显，导致大量线程空循环，自旋转，性能和效率都不是特别好
  - ![](/CAS自旋锁对于atomic类的优化.jpg)
  - 分段加锁以及自动分段迁移 / 合并加锁。，
  - ![](/分段锁.jpg)

### CAS

#### AbstractQueuedSynchronizer，抽象队列同步器

![](/AQS执行.jpg)

- 本身的ReentrantLock 就是一个非公平的锁，公平的话会影响性能
- 不过要知道 java 并发包里很多锁默认的策略都是非公平的，也就是可能后来的线程先加锁，先来的线程后加锁。

- 而一般情况下，非公平的策略都没什么大问题，但是大家要对这个策略做到心里有数，在开发的时候，需要自己来考虑和权衡是要用公平策略还是非公平策略。

  



#### springCloud全家桶

![](/springcloud.jpg)

##### Eureka

- 自我保护机制
  - Eureka在CAP理论当中是属于AP ， 也就说当产生网络分区时，Eureka保证系统的可用性，但不保证系统里面数据的一致性
  - 默认情况下，Eureka Server在一定时间内，没有接收到某个微服务心跳，会将某个微服务注销（90S）。但是当网络故障时，微服务与Server之间无法正常通信，上述行为就非常危险，因为微服务正常，不应该注销。
  - Eureka Server通过自我保护模式来解决整个问题，当Server在短时间内丢失过多客户端时，那么Server会进入自我保护模式，会保护注册表中的微服务不被注销掉。当网络故障恢复后，退出自我保护模式。
  - 宁可保留健康的和不健康的，也不盲目注销任何健康的服务。
  - 客户端每分钟续约数量小于客户端总数的85%时会触发保护机制
  - 多级缓存的优点
    - 尽可能保证了内存注册表数据不会出现频繁的读写冲突问题。
    - 并且进一步保证对 Eureka Server 的大量请求，都是快速从纯内存走，性能极高。
    - 为方便大家更好的理解，同样来一张图，大家跟着图再来回顾一下这整个过程：
- Eureka：各个服务启动时，Eureka Client 都会将服务注册到 Eureka Server，并且 Eureka Client 还可以反过来从 Eureka Server 拉取注册表，从而知道其他服务在哪里
  - ![](/eureka的多级缓存.jpg)
- Ribbon：服务间发起请求的时候，基于 Ribbon 做负载均衡，从一个服务的多台机器中选择一台
- Feign：基于 Feign 的动态代理机制，根据注解和选择的机器，拼接请求 URL 地址，发起请求
- Hystrix：发起请求是通过 Hystrix 的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题
  - 设置 Hystrix 的线程池 ：响应时间、系统高峰 QPS、有多少台机器，来计算出来，线程池的大小以及超时时间！
- Zuul：如果前端、移动端要调用后端系统，统一从 Zuul 网关进入，由 Zuul 网关转发请求给对应的服务

- **其实对于服务，每一个接口都是需要做幂等的，因为其实有fegin和ribbion的重试机制导致的，因为重试的时候是按照原来的参数进行重试的，所以要保证在实现方做一些接口的幂等的校验****



### 分布式事务的解决方案

##### 柔韧事物

- 因为对于微服务的话来说，肯定会引起分布式事物的问题。目前的最理想的方案就是这个：保证最终的一致性

```java
刚性事务：遵循ACID原则，强一致性。
柔性事务：遵循BASE理论，最终一致性；与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。

BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“柔性事务”。
```



### ThreadLocal

- 当很多线程需要多次使用同一个对象，并且需要该对象具有相同初始化值的时候最适合使用ThreadLocal。

- https://www.pianshen.com/article/2853116327/

- http://www.threadlocal.cn/#1

##### threadlocal使用

- 每次使用完ThreadLocal都调用它的remove()方法清除数据

- 将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。
- 这里会涉及到java的引用类型和 java的对象的生命周期

##### java引用类型

​		每种编程语言都有自己操作内存中元素的方式，例如在 C 和 C++ 里是通过指针，而在 Java 中则是通过“引用”。在 Java 中一切都被视为了对象，但是我们操作的标识符实际上是对象的一个引用（reference）。

`//创建一个引用，引用可以独立存在，并不一定需要与一个对象关联 String s;`

- 引用回收
  - 引用计数法：为每个对象添加一个引用计数器，每当有一个引用指向它时，计数器就加1，当引用失效时，计数器就减1，当计数器为0时，则认为该对象可以被回收（目前在Java中已经弃用这种方式了）。
  - 可达性分析算法：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。

- 强引用

  - 使用最普遍的引用，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。
  - 如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时间就会回收该对象。

- 软引用

  - 软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。

- 弱引用

  - VM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。

    ```java
    	private static void testWeakReference() {
    		for (int i = 0; i < 10; i++) {
    			byte[] buff = new byte[1024 * 1024];
    			WeakReference<byte[]> sr = new WeakReference<>(buff);
    			list.add(sr);
    		}
    		
    		System.gc(); //主动通知垃圾回收
    		
    		for(int i=0; i < list.size(); i++){
    			Object obj = ((WeakReference) list.get(i)).get();
    			System.out.println(obj);
    		}
    	}
    ```

- 虚引用

  - 虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。

- 引用队列

  - 引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。

    与软引用、弱引用不同，虚引用必须和引用队列一起使用。

##### java类生命周期

​		java类的生命周期就是指一个class文件从加载到卸载的全过程。

​		https://blog.csdn.net/yanliguoyifang/article/details/80964237![类的生命周期](/类的生命周期.jpg)

​		 其中，验证——准备——解析 称为连接阶段，除了解析外，其他阶段是顺序发生的，而解析可以与这些阶段交叉进行，因为Java支持动态绑定（晚期绑定），需要运行时才能确定具体类型；在使用阶段实例化对象。

- 类的初始化触发
  - 类的加载机制没有明确的触发条件，但是有5种情况下必须对类进行初始化，那么 加载——验证——准备 就必须在此之前完成了。
    - 通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。
    - 通过反射方式执行以上三种行为。
    - 初始化子类的时候，会触发父类的初始化。
    - 虚拟机启动时，初始化一个执行主类；（作为程序入口直接运行时（也就是直接调用main方法）。）
    - 使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、RE_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化
  - 注意，**有且只有五种情况必须对类进行初始化，这**五种情况被称为“主动引用”，除了这五种情况，所有其他的类引用方式都不会触发类初始化，被称为“被动引用”



