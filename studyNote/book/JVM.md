# JVM

### GC

#### 标记定位方式

- 一个是是否引用，不能解决循环引用的问题
- 根可达的算法。能不能达到最终引用。 main  和几个 。有没有最终引用到。

#### GC算法

- **mark-sweep 标记清除**  找出是哪些垃圾，然后直接清除。
  - **缺点**：是导致内存碎片化。然后小洞洞。

- **copying 拷贝**
  - 不管内存多大，直接将内存一分为二，然后使用一边之后使用另外一边。
  - **缺点**：空间浪费巨大。

- **mark-compact 标记压缩**
  - 把回收的数据挪动，保证内存的不碎片化。
  - **缺点**：效率太低 
- ***所以最终的垃圾回收，是综合这三种算法的***
- 最终的垃圾回收：
  - 根据不同的年龄，这个年龄将移到不同的区域
  - 新生代
    - **eden 伊甸区域**
      - 使用的拷贝算法
      - 一般来说，对于程序的对象，一次回收能回收 90%的对象了。
      - 所以 eden 的算法一定是拷贝算法。
      - 每次的清除都是全部清楚的，有用的对象将拷贝到survivor的区域
    - **survivor区**
      - S1
      - S2
  - 老年代

#### 算法

- serial  最开始的使用，但是现在不用了。
  - serial old 使用的就是  标记清除和压缩的算法。其他的区别不大
  - 直接是就是一条线程清理 拒绝所有的线程 。很有可能一天
  - stw  Stop the world
- parallel  scavenge  +  po  并行垃圾回收
  - 多条线程一起清理
  - Stw   线程越来越大
- par new
  - concurrent mark sweep
  - 垃圾回收期 和工作线程一起做。导致工作线程不用停
  - 所以从算法的角度上来说实现特别的难。
  - **所有的并发垃圾回收，都是用三色标记算法**
  - 到目前为止，所有的垃圾回收器  都会有 STW 。只是时间的不同
  - cms的remark  
  - 1.8的G1没问题



#### 分代模型

- 新生代
- 老年代
- jdk1.8默认的模型





##### 运行时数据区

![](E:\codeDir\study-parent\studyNote\book\image\java运行时数据区域.jpg)



### jvm内存模型

**指的就是在JVM拿到内存的时候，对内存的一些分配**

#### 程序计数器（方法）

- 由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存

#### 线程栈区（方法）

- 存对象的引用 和方法。
- 存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

#### 堆区（全局）

- 存对象 

#### 方法区 元数据区 （全局）

- 放一些 常量数据，和一些classloader



### JVM调优

#### 参数

- 直接将最大值和最小值设置一样，可以让程序不会扩缩容浪费时间

- 内存泄漏定位到，哪个类的话，然后看代码逻辑

- 调优

  - 自带命令  

    - top
      - 内存无线增长 内存泄漏
      - jps
      - jstack  线程  

  - 使用阿里的调优工具  arthas

    - 不是图形界面，装在服务器上，消耗的cpu极低
    - 1、启动的时候会有进程，然后只要进入即可
    - 2、dasable 命令 可以知道哪个线程在消耗cpu
    - 3、 然后再有命令去查看消耗的线程。

    - 一、确定进程，比较消耗cpu之类的
    - 二、使用 jmap -histo 1574 |head -20  这个就可以找出，具体的class   多少个  instance  和所占得内存  。知道哪些对象占用的内存。  所以的话，可以判定程序中是否有内存泄漏
    - 牛逼的地方
      - 可以反编译
        - 代码的版本
        - 可以动态代理的反编译
      - 可以使用trace  跟踪方法的耗时   trace ABC   a    类ABC的a方法
      - 可以热更新， 看到线程bug的话，直接修改，然后使用arthas 直接进行热部署

  - 网上的定位

    - 1.通过top命名 shift+P 或 U 分别根据CPU使用和内存使用进程排序
    - 通过进程ID定位出消耗资源线程ID top -Hp 7869 同样排序与1步骤差不多
    - 通过jstack命名 导出线程堆栈信息 jstack 7869
    - 通过jmap命名查看堆中对象 jmap -histo:live 7869 | head -20 定位前20个

  - 还有图形化界面   不要说用的图形界面。极不可能

  - 线下压测的时候，

​	









